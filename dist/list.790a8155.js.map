{"mappings":"ACGA,IAAI,sBAAwB,KACxB,uBAAyB,KACzB,eAAiB,KAOrB,SAAS,wBAEL,AADiB,MAAM,IAAI,CAAC,KAAK,QAAQ,EAChC,OAAO,CAAC,AAAA,IACb,EAAK,SAAS,CAAC,MAAM,CAAC,YACtB,EAAK,KAAK,CAAC,SAAS,CAAG,EAC3B,EACJ,CAEA,SAAS,wBAAwB,CAAQ,EAErC,EAAS,gBAAgB,CAAC,YAAa,AAAC,IACpC,sBAAwB,EACpB,EAAE,YAAY,EAAI,AAAwC,KAAA,IAAjC,EAAE,YAAY,CAAC,aAAa,EACrD,EAAE,YAAY,CAAC,OAAO,CAAC,aAAc,EAAS,OAAO,CAAC,IAAI,EAAI,IAElE,wBACA,WAAW,KACP,EAAS,SAAS,CAAC,GAAG,CAAC,WAC3B,EAAG,EACP,GAEA,EAAS,gBAAgB,CAAC,WAAY,AAAC,IACnC,EAAE,cAAc,GACX,EAAE,YAAY,EAAI,AAAwC,KAAA,IAAjC,EAAE,YAAY,CAAC,aAAa,EACtD,EAAE,YAAY,CAAC,OAAO,CAAC,aAAc,EAAS,OAAO,CAAC,IAAI,EAAI,IAGlE,wBAEA,IAAM,EAAW,EAAE,MAAM,CAAC,OAAO,CAAC,MAElC,GAAI,GAAY,IAAa,sBAAuB,CAChD,IAAM,EAAc,EAAS,qBAAqB,GAC5C,EAAS,EAAY,CAAC,CAAI,EAAY,MAAM,CAAG,CAEhD,CAAA,EAAE,OAAO,CAAG,GACd,EAAS,KAAK,CAAC,SAAS,CAAG,mCAC3B,EAAS,KAAK,CAAC,YAAY,CAAG,KAE7B,EAAS,KAAK,CAAC,SAAS,CAAG,oCAC3B,EAAS,KAAK,CAAC,SAAS,CAAG,GAEnC,CACJ,GAEA,EAAS,gBAAgB,CAAC,OAAQ,AAAC,IAC/B,EAAE,cAAc,GAChB,IAAM,EAAa,EAAE,MAAM,CAAC,OAAO,CAAC,MAKpC,GAFA,wBAEI,GAAc,uBAAyB,IAAe,sBAAuB,CAC7E,IAAM,EAAc,EAAW,qBAAqB,GAC9C,EAAS,EAAY,CAAC,CAAI,EAAY,MAAM,CAAG,CAEjD,CAAA,EAAE,OAAO,CAAG,EACZ,KAAK,YAAY,CAAC,sBAAuB,GAEzC,KAAK,YAAY,CAAC,sBAAuB,EAAW,WAAW,EAEnE,oBACA,sBAAwB,IAC5B,CACJ,GAEA,EAAS,gBAAgB,CAAC,UAAW,KAC7B,uBACA,sBAAsB,SAAS,CAAC,MAAM,CAAC,YAE3C,wBACA,sBAAwB,IAC5B,GAIA,EAAS,gBAAgB,CAAC,aAAc,AAAC,IAGZ,IAArB,EAAE,OAAO,CAAC,MAAM,GAEZ,gBACA,aAAa,gBAGjB,eAAiB,WAAW,KACxB,sBAAwB,EACxB,EAAS,SAAS,CAAC,GAAG,CAAC,YACvB,EAAE,cAAc,EACpB,EAAG,KAEX,GAGA,EAAS,gBAAgB,CAAC,YAAa,AAAC,IAEpC,GAAI,CAAC,sBAAuB,OAC5B,EAAE,cAAc,GAEhB,IAAM,EAAQ,EAAE,OAAO,CAAC,EAAE,CACpB,EAAU,EAAM,OAAO,CACvB,EAAU,EAAM,OAAO,CAIvB,EAAsB,AADN,SAAS,gBAAgB,CAAC,EAAS,GACf,OAAO,CAAC,MAKlD,GAFA,wBAEI,GAAsB,IAAuB,sBAAuB,CAEpE,IAAM,EAAc,EAAmB,qBAAqB,EAGxD,CAAA,EAFW,EAAY,CAAC,CAAI,EAAY,MAAM,CAAG,GAGjD,EAAmB,KAAK,CAAC,SAAS,CAAG,mCACrC,EAAmB,KAAK,CAAC,YAAY,CAAG,KAExC,EAAmB,KAAK,CAAC,SAAS,CAAG,oCACrC,EAAmB,KAAK,CAAC,SAAS,CAAG,GAG7C,CACA,aAAa,gBACb,eAAiB,IACrB,GAEA,EAAS,gBAAgB,CAAC,WAAY,AAAC,IAIlC,GAAI,eAAgB,CACjB,aAAa,gBACb,eAAiB,KACjB,MACJ,CAEA,GAAI,CAAC,sBAAuB,OAE5B,EAAE,cAAc,GAEhB,sBAAsB,SAAS,CAAC,MAAM,CAAC,YACvC,wBAGA,IAAM,EAAY,EAAE,cAAc,CAAC,EAAE,CAC/B,EAAqB,SAAS,gBAAgB,CAAC,EAAU,OAAO,CAAE,EAAU,OAAO,EACnF,EAAkB,EAAqB,EAAmB,OAAO,CAAC,MAAQ,KAEhF,GAAI,GAAmB,uBAAyB,IAAoB,sBAAuB,CACvF,IAAM,EAAc,EAAgB,qBAAqB,GACnD,EAAS,EAAY,CAAC,CAAI,EAAY,MAAM,CAAG,CAEjD,CAAA,EAAU,OAAO,CAAG,EAEpB,KAAK,YAAY,CAAC,sBAAuB,GAGzC,KAAK,YAAY,CAAC,sBAAuB,EAAgB,WAAW,EAExE,mBACJ,CAEA,sBAAwB,IAE5B,GAEA,EAAS,gBAAgB,CAAC,cAAe,KAEjC,iBACA,aAAa,gBACb,eAAiB,MAEjB,uBACA,sBAAsB,SAAS,CAAC,MAAM,CAAC,YAE3C,wBACA,sBAAwB,IAE5B,EACJ","sources":["<anon>","public/js/list/list-features.js"],"sourcesContent":["// --- DRAG AND DROP LOGIC ---\n// Variable to hold the currently dragged list item\nlet currentDraggedElement = null;\nlet currentTouchDropTarget = null;\nlet longPressTimer = null;\n/**\r\n * Attaches drag and drop event listeners (mouse and touch) to a given list item.\r\n * @param {HTMLElement} listItem The <li> element to make draggable.\r\n */ function cleanUpDragOverStyles() {\n    const allItems = Array.from(List.children);\n    allItems.forEach((item)=>{\n        item.classList.remove('dragging');\n        item.style.boxShadow = '';\n    });\n}\nfunction addDragAndDropListeners(listItem) {\n    // --- Mouse Drag Events ---\n    listItem.addEventListener('dragstart', (e)=>{\n        currentDraggedElement = listItem;\n        if (e.dataTransfer && typeof e.dataTransfer.effectAllowed !== 'undefined') e.dataTransfer.setData('text/plain', listItem.dataset.item || '');\n        cleanUpDragOverStyles();\n        setTimeout(()=>{\n            listItem.classList.add('dragging');\n        }, 0);\n    });\n    listItem.addEventListener('dragover', (e)=>{\n        e.preventDefault(); // Crucial: Allows a drop to happen\n        if (e.dataTransfer && typeof e.dataTransfer.effectAllowed !== 'undefined') e.dataTransfer.setData('text/plain', listItem.dataset.item || '');\n        cleanUpDragOverStyles();\n        const targetLi = e.target.closest('li');\n        // Apply dynamic border for insertion point\n        if (targetLi && targetLi !== currentDraggedElement) {\n            const boundingBox = targetLi.getBoundingClientRect();\n            const offset = boundingBox.y + boundingBox.height / 2; // Midpoint of the target li\n            if (e.clientY < offset) {\n                targetLi.style.boxShadow = 'inset 0 3px 0 0 var(--bs-effect)';\n                targetLi.style.borderBottom = '';\n            } else {\n                targetLi.style.boxShadow = 'inset 0 -3px 0 0 var(--bs-effect)';\n                targetLi.style.borderTop = '';\n            }\n        }\n    });\n    listItem.addEventListener('drop', (e)=>{\n        e.preventDefault();\n        const dropTarget = e.target.closest('li');\n        // Clean up drag-over styling from all items\n        cleanUpDragOverStyles();\n        if (dropTarget && currentDraggedElement && dropTarget !== currentDraggedElement) {\n            const boundingBox = dropTarget.getBoundingClientRect();\n            const offset = boundingBox.y + boundingBox.height / 2;\n            if (e.clientY < offset) List.insertBefore(currentDraggedElement, dropTarget);\n            else List.insertBefore(currentDraggedElement, dropTarget.nextSibling);\n            updateItemNumbers();\n            currentDraggedElement = null;\n        }\n    });\n    listItem.addEventListener('dragend', ()=>{\n        if (currentDraggedElement) currentDraggedElement.classList.remove('dragging');\n        cleanUpDragOverStyles(); // Ensure all drag-over styles are removed\n        currentDraggedElement = null; // Clear the dragged item reference\n    });\n    // --- Touch Drag Events ---\n    listItem.addEventListener('touchstart', (e)=>{\n        // Only proceed if one finger is used for drag (multi-touch could be zoom/scroll)\n        if (e.touches.length === 1) {\n            // Start a timer to distinguish between tap and drag\n            if (longPressTimer) clearTimeout(longPressTimer);\n            longPressTimer = setTimeout(()=>{\n                currentDraggedElement = listItem;\n                listItem.classList.add('dragging');\n                e.preventDefault();\n            }, 400); // 400ms threshold for drag vs tap\n        }\n    });\n    listItem.addEventListener('touchmove', (e)=>{\n        if (!currentDraggedElement) return;\n        e.preventDefault(); // Prevent scrolling while dragging\n        const touch = e.touches[0];\n        const clientX = touch.clientX;\n        const clientY = touch.clientY;\n        // Find the element directly under the touch point\n        const targetElement = document.elementFromPoint(clientX, clientY);\n        const newTouchDropTarget = targetElement.closest('li');\n        cleanUpDragOverStyles();\n        if (newTouchDropTarget && newTouchDropTarget !== currentDraggedElement) {\n            // Apply drag-over styling based on touch position\n            const boundingBox = newTouchDropTarget.getBoundingClientRect();\n            const offset = boundingBox.y + boundingBox.height / 2;\n            if (clientY < offset) {\n                newTouchDropTarget.style.boxShadow = 'inset 0 3px 0 0 var(--bs-effect)';\n                newTouchDropTarget.style.borderBottom = '';\n            } else {\n                newTouchDropTarget.style.boxShadow = 'inset 0 -3px 0 0 var(--bs-effect)';\n                newTouchDropTarget.style.borderTop = '';\n            }\n            currentTouchDropTarget = newTouchDropTarget;\n        }\n        clearTimeout(longPressTimer);\n        longPressTimer = null;\n    });\n    listItem.addEventListener('touchend', (e)=>{\n        // Clear drag timer if touch ends quickly (it's a tap, not a drag)\n        if (longPressTimer) {\n            clearTimeout(longPressTimer);\n            longPressTimer = null;\n            return;\n        }\n        if (!currentDraggedElement) return;\n        e.preventDefault(); // Prevent default action on touchend\n        currentDraggedElement.classList.remove('dragging');\n        cleanUpDragOverStyles(); // Remove any lingering drag-over styles\n        // Determine the final drop target\n        const lastTouch = e.changedTouches[0];\n        const finalTargetElement = document.elementFromPoint(lastTouch.clientX, lastTouch.clientY);\n        const finalDropTarget = finalTargetElement ? finalTargetElement.closest('li') : null;\n        if (finalDropTarget && currentDraggedElement && finalDropTarget !== currentDraggedElement) {\n            const boundingBox = finalDropTarget.getBoundingClientRect();\n            const offset = boundingBox.y + boundingBox.height / 2;\n            if (lastTouch.clientY < offset) // Drop above the target\n            List.insertBefore(currentDraggedElement, finalDropTarget);\n            else // Drop below the target\n            List.insertBefore(currentDraggedElement, finalDropTarget.nextSibling);\n            updateItemNumbers(); // Re-number and save the new order\n        }\n        // Reset global variables\n        currentDraggedElement = null;\n        currentTouchDropTarget = null;\n    });\n    listItem.addEventListener('touchcancel', ()=>{\n        // Clean up on touch cancel (e.g., if phone call comes in)\n        if (longPressTimer) {\n            clearTimeout(longPressTimer);\n            longPressTimer = null;\n        }\n        if (currentDraggedElement) currentDraggedElement.classList.remove('dragging');\n        cleanUpDragOverStyles();\n        currentDraggedElement = null;\n        currentTouchDropTarget = null;\n    });\n}\n\n//# sourceMappingURL=list.790a8155.js.map\n","// --- DRAG AND DROP LOGIC ---\r\n\r\n// Variable to hold the currently dragged list item\r\nlet currentDraggedElement = null;\r\nlet currentTouchDropTarget = null;\r\nlet longPressTimer = null;\r\n\r\n/**\r\n * Attaches drag and drop event listeners (mouse and touch) to a given list item.\r\n * @param {HTMLElement} listItem The <li> element to make draggable.\r\n */\r\n\r\nfunction cleanUpDragOverStyles() {\r\n    const allItems = Array.from(List.children);\r\n    allItems.forEach(item => {\r\n        item.classList.remove('dragging');\r\n        item.style.boxShadow = '';\r\n    });\r\n}\r\n\r\nfunction addDragAndDropListeners(listItem) {\r\n    // --- Mouse Drag Events ---\r\n    listItem.addEventListener('dragstart', (e) => {\r\n        currentDraggedElement = listItem;\r\n        if (e.dataTransfer && typeof e.dataTransfer.effectAllowed !== 'undefined') {\r\n            e.dataTransfer.setData('text/plain', listItem.dataset.item || '');\r\n        }\r\n        cleanUpDragOverStyles();\r\n        setTimeout(() => {\r\n            listItem.classList.add('dragging');\r\n        }, 0);\r\n    });\r\n\r\n    listItem.addEventListener('dragover', (e) => {\r\n        e.preventDefault(); // Crucial: Allows a drop to happen\r\n         if (e.dataTransfer && typeof e.dataTransfer.effectAllowed !== 'undefined') {\r\n            e.dataTransfer.setData('text/plain', listItem.dataset.item || '');\r\n        }\r\n\r\n        cleanUpDragOverStyles();\r\n\r\n        const targetLi = e.target.closest('li');\r\n        // Apply dynamic border for insertion point\r\n        if (targetLi && targetLi !== currentDraggedElement) {\r\n            const boundingBox = targetLi.getBoundingClientRect();\r\n            const offset = boundingBox.y + (boundingBox.height / 2); // Midpoint of the target li\r\n\r\n             if (e.clientY < offset) {\r\n               targetLi.style.boxShadow = 'inset 0 3px 0 0 var(--bs-effect)';\r\n               targetLi.style.borderBottom = '';\r\n            } else {\r\n                targetLi.style.boxShadow = 'inset 0 -3px 0 0 var(--bs-effect)';\r\n                targetLi.style.borderTop = '';\r\n            }\r\n        }\r\n    });\r\n\r\n    listItem.addEventListener('drop', (e) => {\r\n        e.preventDefault();\r\n        const dropTarget = e.target.closest('li');\r\n\r\n        // Clean up drag-over styling from all items\r\n        cleanUpDragOverStyles();\r\n\r\n        if (dropTarget && currentDraggedElement && dropTarget !== currentDraggedElement) {\r\n            const boundingBox = dropTarget.getBoundingClientRect();\r\n            const offset = boundingBox.y + (boundingBox.height / 2);\r\n\r\n            if (e.clientY < offset) {\r\n                List.insertBefore(currentDraggedElement, dropTarget);\r\n            } else {\r\n                List.insertBefore(currentDraggedElement, dropTarget.nextSibling);\r\n            }\r\n            updateItemNumbers();\r\n            currentDraggedElement = null;\r\n        }\r\n    });\r\n\r\n    listItem.addEventListener('dragend', () => {\r\n        if (currentDraggedElement) {\r\n            currentDraggedElement.classList.remove('dragging');\r\n        }\r\n        cleanUpDragOverStyles(); // Ensure all drag-over styles are removed\r\n        currentDraggedElement = null; // Clear the dragged item reference\r\n    });\r\n\r\n\r\n    // --- Touch Drag Events ---\r\n    listItem.addEventListener('touchstart', (e) => {\r\n        // Only proceed if one finger is used for drag (multi-touch could be zoom/scroll)\r\n        \r\n        if (e.touches.length === 1) {\r\n            // Start a timer to distinguish between tap and drag\r\n            if (longPressTimer) {\r\n                clearTimeout(longPressTimer);\r\n            }\r\n\r\n            longPressTimer = setTimeout(() => {\r\n                currentDraggedElement = listItem;\r\n                listItem.classList.add('dragging'); \r\n                e.preventDefault();\r\n            }, 400); // 400ms threshold for drag vs tap\r\n        }\r\n    });\r\n\r\n\r\n    listItem.addEventListener('touchmove', (e) => {\r\n\r\n        if (!currentDraggedElement) return;\r\n        e.preventDefault(); // Prevent scrolling while dragging\r\n\r\n        const touch = e.touches[0];\r\n        const clientX = touch.clientX;\r\n        const clientY = touch.clientY;\r\n        \r\n        // Find the element directly under the touch point\r\n        const targetElement = document.elementFromPoint(clientX, clientY);\r\n        const newTouchDropTarget =  targetElement.closest('li');\r\n\r\n   \r\n        cleanUpDragOverStyles();\r\n        \r\n        if (newTouchDropTarget && newTouchDropTarget !== currentDraggedElement) {\r\n            // Apply drag-over styling based on touch position\r\n            const boundingBox = newTouchDropTarget.getBoundingClientRect();\r\n            const offset = boundingBox.y + (boundingBox.height / 2);\r\n\r\n            if (clientY < offset) {\r\n                newTouchDropTarget.style.boxShadow = 'inset 0 3px 0 0 var(--bs-effect)';\r\n                newTouchDropTarget.style.borderBottom = '';\r\n            } else {\r\n                newTouchDropTarget.style.boxShadow = 'inset 0 -3px 0 0 var(--bs-effect)';\r\n                newTouchDropTarget.style.borderTop = '';\r\n            }\r\n            currentTouchDropTarget = newTouchDropTarget;\r\n        } \r\n        clearTimeout(longPressTimer);\r\n        longPressTimer = null;\r\n    }); \r\n    \r\n    listItem.addEventListener('touchend', (e) => {\r\n\r\n       \r\n        // Clear drag timer if touch ends quickly (it's a tap, not a drag)\r\n         if (longPressTimer) { \r\n            clearTimeout(longPressTimer); \r\n            longPressTimer = null;\r\n            return;\r\n        }\r\n       \r\n        if (!currentDraggedElement) return;\r\n         \r\n        e.preventDefault(); // Prevent default action on touchend\r\n\r\n        currentDraggedElement.classList.remove('dragging');\r\n        cleanUpDragOverStyles(); // Remove any lingering drag-over styles\r\n\r\n        // Determine the final drop target\r\n        const lastTouch = e.changedTouches[0];\r\n        const finalTargetElement = document.elementFromPoint(lastTouch.clientX, lastTouch.clientY);\r\n        const finalDropTarget = finalTargetElement ? finalTargetElement.closest('li') : null;\r\n\r\n        if (finalDropTarget && currentDraggedElement && finalDropTarget !== currentDraggedElement) {\r\n            const boundingBox = finalDropTarget.getBoundingClientRect();\r\n            const offset = boundingBox.y + (boundingBox.height / 2);\r\n\r\n            if (lastTouch.clientY < offset) {\r\n                // Drop above the target\r\n                List.insertBefore(currentDraggedElement, finalDropTarget);\r\n            } else {\r\n                // Drop below the target\r\n                List.insertBefore(currentDraggedElement, finalDropTarget.nextSibling);\r\n            }\r\n            updateItemNumbers(); // Re-number and save the new order\r\n        }\r\n        // Reset global variables\r\n        currentDraggedElement = null;\r\n        currentTouchDropTarget = null;\r\n    });\r\n\r\n    listItem.addEventListener('touchcancel', () => {\r\n        // Clean up on touch cancel (e.g., if phone call comes in)\r\n        if (longPressTimer) {\r\n            clearTimeout(longPressTimer);\r\n            longPressTimer = null;\r\n        }\r\n        if (currentDraggedElement) {\r\n            currentDraggedElement.classList.remove('dragging');\r\n        }\r\n        cleanUpDragOverStyles();\r\n        currentDraggedElement = null;\r\n        currentTouchDropTarget = null;\r\n    });\r\n}\r\n\r\n"],"names":["currentDraggedElement","currentTouchDropTarget","longPressTimer","cleanUpDragOverStyles","allItems","Array","from","List","children","forEach","item","classList","remove","style","boxShadow","addDragAndDropListeners","listItem","addEventListener","e","dataTransfer","effectAllowed","setData","dataset","setTimeout","add","preventDefault","targetLi","target","closest","boundingBox","getBoundingClientRect","offset","y","height","clientY","borderBottom","borderTop","dropTarget","insertBefore","nextSibling","updateItemNumbers","touches","length","clearTimeout","touch","clientX","newTouchDropTarget","targetElement","document","elementFromPoint","lastTouch","changedTouches","finalTargetElement","finalDropTarget"],"version":3,"file":"list.790a8155.js.map"}